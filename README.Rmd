---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# itscausal

<!-- badges: start -->
<!-- badges: end -->

Welcome to the package page of itscausal. The goal of itscausal is to flexibly estimate
interrupted time series With causal machine learning.

## Installation

You can install the development version of itscausal from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("ASallin/itscausal", force = TRUE)
```

## Example

This is a basic example which shows you how to solve a common problem:

```{r simulation, echo=TRUE, message=FALSE, warning=FALSE}
library(itscausal)
library(data.table)
library(dplyr)
library(ggplot2)

set.seed(2345983)

# Simulate a time series

# Generate simulated dataset
n_time <- 100 # Number of time points
intervention <- round(0.8 * n_time) # Time point of intervention
n_id <- 60 # Number of unique individuals
constant <- 1
order <- 12 # Order of the autocorrelation
ar_params <- c(
  0.5, 0.3, 0.001, 0,
  0, -.050, -.020, 0, 0,
  0, 0.03, 0.15
) # Autocorrelation parameters with order p

# Dummy covariates
X <- sample(c(0, 1), n_id, T)

# Seasonality
season <- rep(1:12, n_time %/% 12)
season <- c(season, 1:(n_time %% 12))

season_coeff <- rnorm(12, 0, 1)
season_coeff[1] <- 0

season_effect <- season * season_coeff[season]


# Generate the time series
ar_process <- function(n_time, ar_params) {
  errors <- rnorm(n_time, 0, 1) # Generate the random errors
  simulated_data <- numeric(n_time)

  for (i in length(ar_params):n_time) {
    simulated_data[i] <- sum(ar_params * simulated_data[(i - length(ar_params)):(i - 1)]) + errors[i]
  }

  simulated_data
}



# Simulate an ITS
df <- data.frame(
  ID = rep(seq(1:n_id), each = n_time),
  X = rep(X, each = n_time),
  season = rep(
    c(rep(1:12, n_time %/% 12), (1:12)[1:(n_time %% 12)]),
    n_id
  ),
  id.effect = rep(rnorm(n_id, 0, 10), each = n_time),
  # error.time = arima.sim(list(order = c(1, 12, 2), ar = 0.7, ma = c(1,2)),
  #                        n = n_time*n_id-12, sd=1),
  season_effect = rep(season * season_coeff[season], n_id),
  post = rep(c(rep(0, intervention), rep(1, 0.2 * n_time)), n_id),
  time = rep((1:n_time) - intervention, n_id),
  error.ar = unlist(replicate(n_id, ar_process(n_time, ar_params), simplify = F)),
  error = rep(rnorm(n_time, 0, 0.5), n_id)
)

# Set parameters for simulation
param_timetrend <- 0.07
param_dummyintervention <- -0.15
param_slopeintervention <- -0.04


# Program y as a function of time and of post*time
df$y <- with(
  df,
  constant + param_timetrend * (time + abs(min(df$time)))
    + (param_dummyintervention * post) # effect at the cutoff
    + param_slopeintervention * post * (time + abs(min(df$time))) # slope after the cutoff
    + season_effect
    + 0.2 * X
    + 0.03 * X * param_slopeintervention
    + error
  #+ error.ar
)

df$forecast = with(df,
                  constant + 0.075* (time + abs(min(df$time)))
                  + year.effect + season.effect + 0.2*X )

# Final df
df <- df[, c("id", "X", "season", "post", "time", "y")]
df <- data.table(df)


# Simulate y with seasonal effects
df <- df[
  , `:=`(
    model = constant
    + param_timetrend * (time + abs(min(df$time)))
      + season_effect
      + 0.2 * X,
    forecast = constant
    + param_timetrend * (time + abs(min(df$time)))
      + param_dummyintervention
      + param_slopeintervention * (time + abs(min(df$time)))
      + season_effect
      + 0.2 * X
      + 0.03 * X * param_slopeintervention
  )
]

df <- df[, ite := ifelse(post == 0, NA, model - forecast)]
ate5 <- mean(df[time < 6 & post == 1, ]$ite)
ate1 <- mean(df[time < 2 & post == 1, ]$ite)

print(ate5)
print(ate1)
```


We can visualize the its as follows:

```{r graph, echo = FALSE}
# Graph
df %>%
  group_by(time, post) %>%
  summarise(y = mean(y)) %>%
  mutate(y = ifelse(post == 1, NA, y)) |>
  ggplot(aes(y = y, x = time)) +
  geom_line() +
  geom_line(
    aes(
      x = time,
      y = constant + param_timetrend * (time + abs(min(df$time)))
        + season * season_coeff[season]
    ),
    col = "red"
  ) +
  geom_line(
    aes(
      x = time,
      y = ifelse(time < 1, NA,
        constant + param_timetrend * (time + abs(min(df$time)))
          + (param_dummyintervention * post)
          + param_slopeintervention * post * (time + abs(min(df$time)))
          + season * season_coeff[season]
      )
    ),
    col = "blue"
  ) +
  labs(
    x = "Time to/from the intervention",
    y = "Average y per time period"
  ) +
  geom_vline(xintercept = 0, color = "red", linetype = 2) +
  theme_classic()
```


We can reproduce these results using the `itscausal` package.

```{r itscausal}
data <- df

fore <- forecastITS(
  data,
  time = "time",
  INDEX = 0L,
  WINDOW = 12L,
  covariates_time = c("season"),
  covariates_fix = c("X"),
  key = "ID",
  y = "y",
  method = c("lm"),
  K = 5
)

dfFinal <- fore$out

dfFinal %>%
  right_join(data) %>%
  group_by(time) %>%
  summarise(y = mean(y), y.pred = mean(y_hat)) %>%
  ggplot(aes(y = y, x = time)) +
  geom_line() +
  geom_line(aes(y = y.pred, x = time), color = "red") +
  geom_line(
    aes(
      x = time,
      y = constant + param_timetrend * (time + abs(min(df$time)))
        + season * season_coeff[season]
    ),
    col = "#e95a08", linetype = 3, size = 1
  ) +
  labs(
    x = "Time to/from the intervention",
    y = "Average y per time period"
  ) +
  geom_vline(xintercept = 0, color = "red", linetype = 2) +
  theme_classic()
```

```{r ite}
# Now we need a way to compute the ITE
iteM <- iteITS(forecast = fore)
```


## Compute the instantaneous treatment effect for the whole population
```{r InstATE}
InstAte <- ateITS(fore, iteM)
InstATE <- InstAte$InstATE

ggplot(InstATE$pred, aes(x = time, y = ite)) +
  geom_bar(stat = "identity")
```


## Per groupdf
```{r ate}
ate1its <- ateITS(fore, iteM, n.periods = 1)
paste("mean = ", round(ate1its$TATE$pred$ite, 3), "; sd = ", round(ate1its$TATE$sd$sd, 3))

ate5its <- ateITS(fore, iteM, n.periods = 5)
paste("mean = ", round(ate5its$TATE$pred$ite, 3), "; sd = ", round(ate5its$TATE$sd$sd, 3))

ate1
ate5
```